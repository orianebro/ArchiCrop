[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PhD Oriane",
    "section": "",
    "text": "Preface\nThis book keeps track of the work made during the PhD of Oriane Braud, entitled “Multiscale hybrid modeling framework for intercrops: the best of plant and crop models”. This PhD is carried out from November 2023 to 2026 at CIRAD (UMRs AGAP and AMAP), as part of European project IntercropValuES, and is supervised by Myriam Adam, Marc Jaeger, Christophe Pradal, Remi Vezy and Thomas Arsouze.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "abstract.html",
    "href": "abstract.html",
    "title": "1  Abstract",
    "section": "",
    "text": "In progress …",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Abstract</span>"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "In progress …\nTalk about intercropping as an agro-ecological practice, the barriers, the importance of modeling, the existing models (crop and FSPM) and their characteristics, their limits as for modeling intercrops, focus on evaluating how hypotheses in crop models are off the mark, for processes occuring in shoot and root, and how to modify the formalisms corresping to processes that are off the mark in STICS crop model in particular.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html",
    "href": "structural_cereal_model.html",
    "title": "3  Structural cereal model",
    "section": "",
    "text": "3.1 Create a parametric leaf\nThe leaf blade is represented as a surface.\nA parametric leaf is here defined by sample points (here 12), described by two sets of coordinates:\n- \\((x,y)\\): coordinates for the midrib in a vertical plane, give the curvature of the leaf;\n- \\((s,r)\\): curviliear abcissa (i.e. length along midrib) and relative length-dependent leaf width.\nNote that \\(s\\) can be expressed as a function of \\(x\\) and \\(y\\), at point \\(p \\neq 0\\), as follows: $ s_p(x,y) = $.\nThe origin represents the leaf base.\nCode\n## Imports\n\n# from installed packages\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom heapq import *\nfrom scipy.interpolate import splprep, splev\nfrom scipy.integrate import simps, trapz\nfrom openalea.plantgl.all import Vector3\n\n# from ./src\nfrom cereals_leaf import leaf_shape_perez, sr_prevot, parametric_leaf\n# or\n# from simple_maize import leaf_shape_perez, sr_prevot, parametric_leaf\n# from fitting import leaf_shape_perez\nfrom generator import curvilinear_abscisse\nfrom fitting import fit2, fit3, simplify\nfrom simplification import distance, cost\n\n## Code for generating a parametric leaf for a cereal \npl=parametric_leaf(nb_segment=10, insertion_angle=40, scurv=0.7, curvature=70, alpha=-2.3)\n\nfig, (ax1, ax2) = plt.subplots(nrows=2) \n# fig.suptitle('Parametric leaf')\n\nax1.plot(pl[0], pl[1], '.-', c=\"green\")\nax1.set_xlabel('x')\nax1.set_ylabel('y')\nax1.set_title(\"Coordinates of the midrib in a vertical plane\")\n\nax2.plot(pl[2], pl[3], '.-', c=\"green\")\nax2.plot(pl[2], -pl[3], '.-', c=\"green\")\nax2.plot(np.arange(0,1.1,0.1), np.zeros(11), c=\"green\", ls=\"dashed\")\nax2.set_xlabel('s')\nax2.set_ylabel('r')\nax2.set_title(\"Flattened leaf shape\")\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\nCode\n## Imports\n\n# from installed packages\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy.interpolate import interp2d\nimport matplotlib.tri as mtri\n\n# from./src\nfrom fitting import leaf_to_mesh_2d\n\n## Code for representing the parametric leaf in 3D (ignore excess lines)\nx=pl[0]\ny=pl[1]\ns=pl[2]\nr=pl[3]\n\npts,ind=leaf_to_mesh_2d(x, y, r)\n\nxs=[pt[0] for pt in pts]\nys=[pt[1] for pt in pts]\nzs=[pt[2] for pt in pts]\n    \nX,Y=np.meshgrid(xs, ys)\n\ntri=mtri.Triangulation(xs, ys)\n\nfig=plt.figure()\nax=fig.add_subplot(111, projection='3d')\nax.scatter(xs,ys,zs,c=\"green\")\nax.plot(xs,ys,zs,c=\"green\")\nax.plot(xs,np.zeros(len(ys)),zs,c=\"green\",ls=\"dashed\")\nax.set_title(\"3D representation of a leaf shape with curvature\")\nplt.show()\nPlease ignore excess straight lines.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#generate-leaf-azimuth-series",
    "href": "structural_cereal_model.html#generate-leaf-azimuth-series",
    "title": "3  Structural cereal model",
    "section": "3.2 Generate leaf azimuth series",
    "text": "3.2 Generate leaf azimuth series\nLeaves grow around an axis with a given phyllotaxy, represented here as an angle from leaf to leaf (e.g. spiral with a given angle or alternate distichous = \\(180^o\\)).\n\n\nCode\n## Imports\n\n# from installed packages \n# from itertools import cycle\n\n# from ./src\nfrom plant_design import leaf_azimuth\n\n## Code for generating leaf azimuths series for a given phyllotaxy\nnb_phy=10\nphyllotactic_angle=137\nspiral=True\nphyllotactic_deviation=0\nplant_orientation=0\n\nla=leaf_azimuth(size=nb_phy, \n                phyllotactic_angle=phyllotactic_angle, \n                phyllotactic_deviation=phyllotactic_deviation, \n                plant_orientation=plant_orientation, \n                spiral=spiral)\n\nx=np.cos(la*np.pi/180)\ny=np.sin(la*np.pi/180)\nz=np.linspace(1,len(la)+1,len(la))\n\nfig,ax=plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of phyllotaxy\")\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#manage-internode-lengths",
    "href": "structural_cereal_model.html#manage-internode-lengths",
    "title": "3  Structural cereal model",
    "section": "3.3 Manage internode lengths",
    "text": "3.3 Manage internode lengths\nInternodes on an axis have varying lengths. The repartition of their lengths along the axis can be approximated with a geometric model.\n\n\nCode\ndef geometric_dist(height, nb_phy, q=1):\n    \"\"\" returns distances between individual leaves along a geometric model \"\"\"\n\n    if q==1:\n        u0=float(height)/nb_phy\n    else:\n        u0=height*(1.-q)/(1.-q**(nb_phy+1))\n\n    return [u0*q**i for i in range(nb_phy)]\n\n\n\n\nCode\n## Code for applying lengths to internodes according to a geometric model\nplant_height=15\nq=1.5\n\nx=np.cos(la*np.pi/180)\ny=np.sin(la*np.pi/180)\nz=geometric_dist(height=plant_height, \n                   nb_phy=nb_phy, \n                   q=q)\n\nfig,ax=plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of the repartition of internode length along the stem\")\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#manage-leaf-lengths-as-a-function-of-height",
    "href": "structural_cereal_model.html#manage-leaf-lengths-as-a-function-of-height",
    "title": "3  Structural cereal model",
    "section": "3.4 Manage leaf lengths as a function of height",
    "text": "3.4 Manage leaf lengths as a function of height\nLeaves that grow on an axis have varying lengths. The repartition of their lengths along the axis can be approximated with a bell shaped model.\n\n\nCode\ndef bell_shaped_dist(max_leaf_length, nb_phy, rmax=.7, skew=0.15):\n    \"\"\" returns leaf area of individual leaves along bell shaped model \"\"\"\n\n    k = -np.log(skew) * rmax\n    r = np.linspace(1. / nb_phy, 1, nb_phy)\n    relative_length = np.exp(-k / rmax * (2 * (r - rmax) ** 2 + (r - rmax) ** 3))\n    # leaf_length = relative_length / relative_length.sum() * max_leaf_length\n    leaf_length = relative_length * max_leaf_length\n    return leaf_length.tolist()\n\n\n\n\nCode\n## Code for applying lengths to leaves according to a bell shaped model\nmax_leaf_length=50\n\nbsd=bell_shaped_dist(max_leaf_length=max_leaf_length, \n                     nb_phy=nb_phy, \n                     rmax=.7, \n                     skew=0.15)\n\nx=np.cos(la*np.pi/180)*bsd\ny=np.sin(la*np.pi/180)*bsd\nz=geometric_dist(height=plant_height, \n                   nb_phy=nb_phy, \n                   q=q)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection='3d'))\nfor i,a in enumerate(la):\n    ax.plot(np.linspace(0,x[i],2), np.linspace(0,y[i],2), [z[i],z[i]], c=\"green\")\nax.plot([0,0], [0,0], [0,z[-1]], c=\"green\")\n\nax.set_title(\"3D representation of the repartition of leaf length along the stem\")\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#arrange-a-leaf-to-be-placed-along-a-stem-with-a-given-inclination.",
    "href": "structural_cereal_model.html#arrange-a-leaf-to-be-placed-along-a-stem-with-a-given-inclination.",
    "title": "3  Structural cereal model",
    "section": "3.5 Arrange a leaf to be placed along a stem with a given inclination.",
    "text": "3.5 Arrange a leaf to be placed along a stem with a given inclination.\nA leaf must undergo a translation to be placed against the surface of the stem (tangent to it), and a rotation to be tilted like the stem (inclination = 1 if main stem).\n\n\nCode\n## Imports\n\n# from installed packages\nfrom math import pi, cos, sin, radians\nimport openalea.plantgl.all as pgl\n\n# from ./src\n# from cereals_leaf import arrange_leaf\n# or \nfrom geometry import arrange_leaf\n\n## Code for placing a leaf against a stem element (here a cylinder), with a given inclination\nstem_diameter=0.5\ninclination=1\n\nal=arrange_leaf(leaf=pl, \n                stem_diameter=stem_diameter, \n                inclination=inclination, \n                relative=True)\n\nx=al[0]\ny=al[1]\ns=al[2]\nr=al[3]\n\npts,ind=leaf_to_mesh_2d(x, y, r)\n\nxs=[pt[0] for pt in pts]\nys=[pt[1] for pt in pts]\nzs=[pt[2] for pt in pts]\n    \nX,Y=np.meshgrid(xs, ys)\n\ntri=mtri.Triangulation(xs, ys)\n\nfig=plt.figure()\nax=fig.add_subplot(111, projection='3d')\nax.plot(xs,ys,zs,c=\"green\")\nax.plot([xs[0],xs[0]],[ys[0],-ys[0]],[0,0],c=\"green\")\nax.plot(xs,np.zeros(len(ys)),zs,c=\"green\",ls=\"dashed\")\n\nradius=stem_diameter/2\nz=np.linspace(0, zs[-1])\ntheta=np.linspace(0, 2*np.pi)\ntheta_grid, z_stem=np.meshgrid(theta, z)\nx_stem=radius*np.cos(theta_grid)\ny_stem=radius*np.sin(theta_grid)\n\nax.plot_surface(x_stem, y_stem, z_stem, color=\"green\")\n\nax.set_title(\"3D representation of the placement of a leaf along a stem\")\n\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#build-the-whole-plant-shoot-in-3d-as-an-mtg.",
    "href": "structural_cereal_model.html#build-the-whole-plant-shoot-in-3d-as-an-mtg.",
    "title": "3  Structural cereal model",
    "section": "3.6 Build the whole plant shoot in 3D, as an MTG.",
    "text": "3.6 Build the whole plant shoot in 3D, as an MTG.\nAn MTG (Multiscale Tree Graph) is created as a representation of a parametrized cereal shoot.\nThe different scales are: - Plant\n- Axis\n- Metamer\n- Stem / Leaf\n- StemElement / LeafElement\n\n\nCode\n## Imports\n\n# from installed packages\nimport openalea.plantgl.all as pgl\nfrom openalea.mtg.turtle import TurtleFrame\nfrom openalea.mtg import MTG, fat_mtg\nfrom scipy.interpolate import interp1d\nimport pandas\n\n# from ./src\nfrom geometry import slim_cylinder, stem_mesh, _is_iterable, as_tuples, addSets, leaf_mesh, compute_element, mtg_interpreter\n# from cereals_leaf import leaf_mesh\nfrom geometry import CerealsTurtle, CerealsVisitor\nfrom fitting import leaf_element, leaf_to_mesh_2d, leaf_to_mesh, mesh4, plantgl_shape   # leaf_to_mesh_new ?\nfrom plant_design import get_form_factor, blade_dimension, stem_dimension\nfrom generator import majors_axes_regression, line_projection, as_leaf, as_plant, cereals as cereals_generator\n# not neccessary to import, but useful to see which functions are used \n\n\ndef build_shoot(stem_radius, insertion_heights, leaf_lengths, leaf_areas, leaf_azimuths=None, leaf_shapes=None):\n    \"\"\"create a shoot\n\n    Args:\n        stem_radius: (float) the stem radius\n        insertion_heights: list of each leaf insertion height\n        leaf_lengths: list of each leaf length (blade length)\n        leaf_areas: list of each blade area\n        collar_visible: list of each collar height or True if the collar is visible and False if it is not\n        leaf_shapes: list of each leaf shape, if it is not known write None\n        leaf_azimuths: list of each leaf azimuth, if it is not known write None\n\n    Returns:\n        shoot: \n\n    \"\"\"\n    ranks = range(1, len(leaf_lengths) + 1)\n    ntop = max(ranks) - np.array(ranks) + 1\n    if leaf_shapes is None:\n        a_leaf = parametric_leaf()\n        leaf_shapes = [a_leaf for r in ranks]\n    if leaf_azimuths is None:\n        leaf_azimuths = leaf_azimuth(len(ranks))\n    leaf_azimuths[1:] = np.diff(leaf_azimuths)\n    ff = [get_form_factor(leaf) for leaf in leaf_shapes]\n    blades = blade_dimension(area=leaf_areas, length=leaf_lengths, ntop=ntop)\n    stem = stem_dimension(h_ins=insertion_heights, d_internode=np.array(stem_radius) * 2, ntop=ntop)\n    df = blades.merge(stem)\n    df['leaf_azimuth'] = leaf_azimuths\n    df['leaf_rank'] = ranks\n    df['leaf_shape'] = [leaf_shapes[n - 1] for n in df.leaf_rank]\n    return df, cereals_generator(plant=df)\n\n\n\n\nCode\n# see problems with this function\ndef build_shoot_w_pseudo(nb_phy, plant_height, insertion_heights, leaf_lengths, leaf_areas, \n                pseudostem_dist=1.4, stem_dist=1.2,\n                diam_base=2.5, diam_top=1, pseudostem_height=20, \n                leaf_azimuths=None, leaf_shapes=None, wl=0.1):\n    \"\"\"create a shoot, with pseudostems and stems\n\n    Args:\n        stem_radius: (float) the stem radius\n        insertion_heights: list of each leaf insertion height\n        leaf_lengths: list of each leaf length (blade length)\n        leaf_areas: list of each blade area\n        collar_visible: list of each collar height or True if the collar is visible and False if it is not\n        leaf_shapes: list of each leaf shape, if it is not known write None\n        leaf_azimuths: list of each leaf azimuth, if it is not known write None\n\n    Returns:\n        shoot: \n\n    \"\"\"\n    ranks = range(1, len(leaf_lengths) + 1)\n    ntop = max(ranks) - np.array(ranks) + 1\n\n    nb_phy = int(nb_phy)\n\n    # Lejeune an Bernier formula + col =\n    nb_young_phy = int(round((nb_phy - 1.95) / 1.84 / 1.3))\n\n    # distances between leaves\n    pseudostem = geometric_dist(pseudostem_height, nb_young_phy,\n                                pseudostem_dist)\n    stem = geometric_dist(plant_height - pseudostem_height,\n                          nb_phy - nb_young_phy, stem_dist)\n    internode = pseudostem + stem\n    # stem diameters\n    diameter = ([diam_base] * nb_young_phy +\n                np.linspace(diam_base, diam_top,\n                            nb_phy - nb_young_phy).tolist())\n    \n    if leaf_shapes is None:\n        a_leaf = parametric_leaf()\n        leaf_shapes = [a_leaf for r in ranks]\n    if leaf_azimuths is None:\n        leaf_azimuths = leaf_azimuth(len(ranks))\n    leaf_azimuths[1:] = np.diff(leaf_azimuths)\n    ff = [get_form_factor(leaf) for leaf in leaf_shapes]\n    # blades = blade_dimension(area=leaf_areas, length=leaf_lengths, ntop=ntop)\n    blades = blade_dimension(length=leaf_lengths, form_factor=ff, ntop=ntop, wl=wl)\n    # stem = stem_dimension(h_ins=insertion_heights, d_internode=diameter, ntop=ntop)\n    stem = stem_dimension(internode=internode, d_internode=diameter, ntop=ntop)\n    \n    df = blades.merge(stem)\n    df['leaf_azimuth'] = leaf_azimuths\n    df['leaf_rank'] = ranks\n    df['leaf_shape'] = [leaf_shapes[n - 1] for n in df.leaf_rank]\n    return df, cereals_generator(plant=df)\n\n# shoot, g = build_shoot(3.0, [2,4,6,8], [2,4,6,8], [2,4,6,8])\n# scene, nump = build_scene(g)\n# display_scene(scene)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#display-scenes-according-to-different-scenarii",
    "href": "structural_cereal_model.html#display-scenes-according-to-different-scenarii",
    "title": "3  Structural cereal model",
    "section": "3.7 Display scenes according to different scenarii",
    "text": "3.7 Display scenes according to different scenarii\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.plantgl import *\n\n# Set nice color for plants\nnice_green=Color3((50,100,0))\n\n\n\n3.7.1 A single cereal\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.plantgl import *\n\n# from ./src\nfrom display import display_mtg, build_scene, display_scene\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating a 3D cereal shoot from descritive parameters\n# Parameters \nstem_radius=1 \nheight=1500                 # from crop model\nnb_phy=15                   # fixed max nb of phytomers\nmax_leaf_length=70 \ninsertion_angle=40\nscurv=0.7\ncurvature=80\nphyllotactic_angle=120\nspiral=True\n\n# Functions calls\ninsertion_heights=np.array(geometric_dist(height, \n                                          nb_phy, \n                                          q=1.2)) # further separate stem and pseudo stem, cf simple maize\n\nleaf_lengths=np.array(bell_shaped_dist(max_leaf_length=max_leaf_length, \n                                       nb_phy=nb_phy, \n                                       rmax=0.7, \n                                       skew=0.15)) # plant area --&gt; max leaf length\n# leaf_areas=bell_shaped_dist(plant_area=1, nb_phy=15, rmax=0.7, skew=0.15) # cf blade_dimension\n\na_leaf = parametric_leaf(nb_segment=10, \n                         insertion_angle=insertion_angle, \n                         scurv=scurv, \n                         curvature=curvature, \n                         alpha=-2.3)\n\nleaf_shapes = [a_leaf for l in leaf_lengths] # possible to replace leaf_length by nb_phy or...\n\nleaf_azimuths = leaf_azimuth(size=len(leaf_lengths), \n                             phyllotactic_angle=phyllotactic_angle, \n                             phyllotactic_deviation=15, \n                             plant_orientation=0, \n                             spiral=spiral)\n\nshoot, g_single = build_shoot(stem_radius=stem_radius, \n                              insertion_heights=insertion_heights, \n                              leaf_lengths=leaf_lengths, \n                              leaf_areas=None, \n                              leaf_shapes=leaf_shapes, \n                              leaf_azimuths=leaf_azimuths)\n\n# Build and display scene\nscene_single, nump = build_scene(g_single, \n                                 leaf_material=Material(nice_green), \n                                 stem_material=Material(nice_green))\n# display_scene(scene_single) # display in separate window\nPlantGL(scene_single) # display in notebook\n\n\n\n\n\nLet’s dig into the propreties of the MTG of a cereal shoot.\n\n\nCode\n## Imports\n\n# from installed packages\nfrom oawidgets.mtg import *\n\n\n## Code for exploring the MTG of the generated cereal shoot\n\n# Properties on the MTG: this exclude all the topological properties\nprint(g_single.property_names())\n\n# Retrieve one property for the MTG (dict)\n\nlabels = g_single.property('label')\n# print(labels)\n\nlength = g_single.property('length')\n# print(length)\n\nleaf_lengths=[]\nleaf_ind=[]\ninternode_lengths=[]\ninternode_ind=[]\nfor k,v in length.items():\n    if k%2==0: # could have done it using labels\n        internode_ind.append(k)\n        internode_lengths.append(v)\n    else:\n        leaf_ind.append(k)\n        leaf_lengths.append(v)\n\nwidth = g_single.property('shape_max_width')\n# print(width)\n\nleaf_widths=[]\nfor k,v in width.items():\n    leaf_widths.append(v)\n\n\nplt.figure()\nplt.plot(leaf_ind, leaf_lengths, c=\"green\", label=\"Leaf lengths\") # == 'shape_mature_length' for final plant\nplt.plot(leaf_ind, leaf_widths, c=\"purple\", label=\"Leaf widths\")\nplt.plot(internode_ind, internode_lengths, c=\"orange\", label=\"Internode lengths\")\nplt.xlabel(\"Vertices\")\nplt.ylabel(\"Lengths (cm)\")\nplt.title(\"MTG properties\")\nplt.legend()\nplt.show()\n\n\n['edge_type', 'label', 'length', 'is_green', 'diameter_base', 'diameter_top', 'azimuth', 'shape', 'shape_mature_length', 'visible_length', 'srb', 'srt', 'lrolled', 'd_rolled', 'shape_max_width', 'stem_diameter', 'geometry', 'anchor_point', 'color']\n\n\n\n\n\nThe leaf lengths and widths follow the bell shaped curve described before.\nThe first internode in the MTG actually corresponds to the pseudostem, i.e. the about 4 to 8 short first internodes that rapidly lose their leaves. The lengths following internodes follow the geometric model described before.\n\n\n3.7.2 A cereal crop with variability\n\n\nCode\n## Imports\n\n# from installed packages\nfrom random import *\n\n# from ./src\nfrom stand import agronomic_plot\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating a random cereal crop from descritive parameters with variability \n# Fix a seed\nseed(1)\n\n# Initialize the list of plants\nplants_in_crop=[]\n\n# Fixed parameters for all plants\nlength_plot=5\nwidth_plot=5\nsowing_density=10\nplant_density=10\ninter_row=0.5\nnplants, positions, domain, domain_area, unit = agronomic_plot(length_plot, \n                                                               width_plot, \n                                                               sowing_density, \n                                                               plant_density, \n                                                               inter_row, \n                                                               noise=0.1)\n\n# For loop over all the plants in the crop\nfor n in range(nplants):\n    # Parameters varying among plants\n    stem_radius=1 \n    height=1000*(1+random()-0.5) \n    nb_phy=15 \n    max_leaf_length=50*(1+random()-0.5)\n    insertion_angle=40*(1+random()-0.5)\n    scurv=0.7*(1+random()-0.5)\n    curvature=70*(1+random()-0.5)\n    phyllotactic_angle=137*(1+random()-0.5)\n    spiral=True\n\n    # Functions calls\n    insertion_heights=np.array(geometric_dist(height, nb_phy, q=1.2)) \n    leaf_lengths=np.array(bell_shaped_dist(max_leaf_length=max_leaf_length, nb_phy=nb_phy, rmax=0.7, skew=0.15)) \n    a_leaf = parametric_leaf(nb_segment=10, insertion_angle=insertion_angle, scurv=scurv, curvature=curvature, alpha=-2.3)\n    leaf_shapes = [a_leaf for l in leaf_lengths]\n    leaf_azimuths = leaf_azimuth(size=len(leaf_lengths), phyllotactic_angle=phyllotactic_angle, phyllotactic_deviation=15, \n                                 plant_orientation=random()*360, spiral=spiral)\n    shoot, g_var = build_shoot(stem_radius=stem_radius, insertion_heights=insertion_heights, leaf_lengths=leaf_lengths, \n                               leaf_areas=None, leaf_shapes=leaf_shapes, leaf_azimuths=leaf_azimuths)\n\n    # Fill the list of plants\n    plants_in_crop.append(g_var)\n\n# Build and display scene\nscene_var, nump = build_scene(plants_in_crop, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n# display_scene(scene_var)\nPlantGL(scene_var)\n\n\n\n\n\n\n\n3.7.3 A seemingly growing plant\n\n\nCode\n## Inputs\n\n# from installed packages\nfrom openalea.plantgl.all import *\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating a \"growing\" cereal shoot from descritive parameters\n# Fix a seed\nseed(1)\n\n# Initialize the list of plant MTGs at different stages\ngrowing_plants=[]\n\n# Parameters fixing final plant or unchanged with \"growth\"\nnplants=10\npositions=[(x,0,0) for x in range(-500, 500, 100)]\nfinal_height=1000\nfinal_nb_phy=2*nplants\nheights=geometric_dist(final_height, final_nb_phy, 1.2)\n# insertion_heights=np.array(geometric_dist(height, nb_phy, q=1.2))\nstem_radius=2 \ninsertion_angle=30\nscurv=0.7\ncurvature=100\nphyllotactic_angle=137\nspiral=True\n\n# For loop for generating plants at different stages\nfor n in range(1,nplants+1):\n    # Parameters varying when \"growing\"\n    height=10*heights[2*n-1]\n    nb_phy=2*n \n    max_leaf_length=5*2*n\n    \n    # Functions calls\n    insertion_heights=np.array(geometric_dist(height, nb_phy, q=1.2)) \n    leaf_lengths=np.array(bell_shaped_dist(max_leaf_length=max_leaf_length, nb_phy=nb_phy, rmax=0.7, skew=0.15)) \n    a_leaf = parametric_leaf(nb_segment=10, insertion_angle=insertion_angle, scurv=scurv, curvature=curvature, alpha=-2.3)\n    leaf_shapes = [a_leaf for l in leaf_lengths] \n    leaf_azimuths = leaf_azimuth(size=len(leaf_lengths), phyllotactic_angle=phyllotactic_angle, \n                                 phyllotactic_deviation=15, plant_orientation=0, spiral=spiral)\n    shoot, g_grow = build_shoot(stem_radius=stem_radius, insertion_heights=insertion_heights, leaf_lengths=leaf_lengths, \n                                leaf_areas=None, leaf_shapes=leaf_shapes, leaf_azimuths=leaf_azimuths)\n\n    # Fill the list with MTG of \"growing\" plant\n    growing_plants.append(g_grow)\n\n# Build and display scene\nscene_grow, nump = build_scene(growing_plants[2:], positions[2:], leaf_material=Material(nice_green), stem_material=Material(nice_green))\n# display_scene(scene_grow)\nPlantGL(scene_grow)\n\n\n\n\n\n\n\n3.7.4 An intercrop organized in rows\n\n\nCode\n## Inputs\n\n# from installed packages\nfrom openalea.plantgl.all import Material, Color3, Shape, Scene, Viewer, Translated, AxisRotated\n\n# Enable plotting with PlantGL\n%gui qt\n\n## Code for generating an intercrop from descritive parameters\n\n# Fix a seed\nseed(1)\n\ndef plant(height, nb_phy, max_leaf_length, phyllotactic_angle, spiral):\n    \"\"\" return the MTG of a cereal shoot generative from descriptive parameters \"\"\"\n    stem_radius=1 \n    insertion_angle=30\n    scurv=0.7\n    curvature=100\n    \n    insertion_heights=np.array(geometric_dist(height, nb_phy, q=1.2)) \n    leaf_lengths=np.array(bell_shaped_dist(max_leaf_length=max_leaf_length, nb_phy=nb_phy, rmax=0.7, skew=0.15)) \n    a_leaf = parametric_leaf(nb_segment=10, insertion_angle=insertion_angle, scurv=scurv, curvature=curvature, alpha=-2.3)\n    leaf_shapes = [a_leaf for l in leaf_lengths] \n    leaf_azimuths = leaf_azimuth(size=len(leaf_lengths), phyllotactic_angle=phyllotactic_angle, \n                                 phyllotactic_deviation=15, plant_orientation=random()*360, spiral=spiral)\n    shoot, g = build_shoot(stem_radius=stem_radius, insertion_heights=insertion_heights, leaf_lengths=leaf_lengths, \n                           leaf_areas=None, leaf_shapes=leaf_shapes, leaf_azimuths=leaf_azimuths)\n    \n    return g\n\n\n# Organize the plant mixture in alternate rows\nn_rows = 10\nlen_rows = 10\n\nd_inter = 70\nd_intra = 50\n\ndef plant_in_row(i):\n     if i%(4*d_inter)==0 or i%(4*d_inter)==d_inter: return plant(height=1700, nb_phy=15, max_leaf_length=100, phyllotactic_angle=137, spiral=True)\n     else: return plant(height=900, nb_phy=20, max_leaf_length=40, phyllotactic_angle=60, spiral=True)\n\n\nplants_in_intercrop = [plant_in_row(x) for x in range(0, n_rows*d_inter, d_inter) for y in range(0, len_rows*d_intra, d_intra)]\n\npositions=[(x,y,0) for x in range(0, n_rows*d_inter, d_inter) for y in range(0, len_rows*d_intra, d_intra)]\n\n# Build and display scene\nscene_ic, nump = build_scene(plants_in_intercrop, positions, leaf_material=Material(nice_green), stem_material=Material(nice_green))\n# display_scene(scene_ic)\nPlantGL(scene_ic)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#tillering-branching",
    "href": "structural_cereal_model.html#tillering-branching",
    "title": "3  Structural cereal model",
    "section": "3.8 Tillering / Branching",
    "text": "3.8 Tillering / Branching\nIn progress …",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#light-interception-with-caribu",
    "href": "structural_cereal_model.html#light-interception-with-caribu",
    "title": "3  Structural cereal model",
    "section": "3.9 Light interception with Caribu",
    "text": "3.9 Light interception with Caribu\nIn progress …\nWe have to configure Caribu to simulate the same light as in STICS\n\n\nCode\n## Code for computing light interception with Caribu\nsky = str(data_path('Turtle16soc.light'))\n# opts = map(str, [data_path('par.opt'), data_path('nir.opt')])\n\n# complete set of files\ncs = CaribuScene(scene=scene_ic, light=sky) # opt=opts, ) #pattern=pattern)\nraw,agg=cs.run(simplify=True)\n\nscene,values = cs.plot(raw['Ei'],display=False)\n\nv99 = np.percentile(values, 99)\nnvalues=np.array(values)\nnvalues[nvalues&gt;v99]=v99\nvalues = nvalues.tolist()\n\nPlantGL(scene, group_by_color=False, property=values)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "structural_cereal_model.html#next-steps",
    "href": "structural_cereal_model.html#next-steps",
    "title": "3  Structural cereal model",
    "section": "3.10 Next steps",
    "text": "3.10 Next steps\n\nAdapt for different species (parameters for cereals, some functions for legumes)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Structural cereal model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html",
    "href": "dynamic_model.html",
    "title": "4  Dynamic model",
    "section": "",
    "text": "4.1 Conceptual diagram\nThe main stem grows according to the crop model’s plant height. At the end of the growth of an internode, a leaf appears. The appearance of a leaf is triggered by fixed phyllochron (different for tillers?).\nCf Fournier et al, 2005 for leaf elongation\nThe angle of the leaf with its axis is leaf-age dependent. The leaf blade curvature depends on the angle with the axis and the leaf length.\nThe reproductive organs appear from a given thermal time, when the leaves have stopped growing.\nLeaf senescence is constrained by crop model, as it has a direct influence on LAI (green LAI vs. yellow LAI ?).\nThe branching pattern is set (Tillers (Zhu et al., 2015)).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html#conceptual-diagram",
    "href": "dynamic_model.html#conceptual-diagram",
    "title": "4  Dynamic model",
    "section": "",
    "text": "Conceptual diagram of shoot FSPM (not final version, some errors)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html#time-dependent-parametrization-of-leaf-area",
    "href": "dynamic_model.html#time-dependent-parametrization-of-leaf-area",
    "title": "4  Dynamic model",
    "section": "4.2 Time-dependent parametrization of leaf area",
    "text": "4.2 Time-dependent parametrization of leaf area\n\\[ \\mathcal{A_normalized} = 2 * |\\int_{0}^{1} \\mathcal{C}(s(u))ds(u)| \\] \\[ \\mathcal{A} = \\mathcal{A_scaled} = 2 * w * |\\int_{0}^{L} \\mathcal{C}(\\frac{s(u)}{L})d\\frac{s(u)}{L}| \\] \\[ \\frac{d\\mathcal{A}}{dt} = 2 * w * |\\int_{ds(t)/L} \\mathcal{C}(\\frac{s(u)}{L})d\\frac{s(u)}{L}| \\]\n\n\\(\\mathcal{A}\\) : final leaf area (or surface), in \\(cm^2\\)\n\\(\\frac{d\\mathcal{A}}{dt}\\) : gain in area, in \\(cm^2\\), for a given leaf for a given time step \\(dt\\) (given by crop model)\n\n\\(\\mathcal{C}\\) : curve of the evolution of the leaf width along the leaf, from tip to base\n\\(s(t)\\) : curvilinear abscissa of the midrib, in \\(cm\\), as a function of thermal time \\(t\\), such that: $ ds(t) = $\n\\(w\\) : final maximal width of the leaf, in \\(cm\\) (to fix/vary within a reasonable range)\n\\(L\\) : final length of the leaf, in \\(cm\\) (to fix/vary within a reasonable range)\n\\(t\\) : thermal time, in \\(^oC.day\\)\n\nThe objective is to find, for each growing leaf, at each time step, and for a given leaf area provided to the leaf \\(\\frac{d\\mathcal{A}}{dt}\\), how much length \\(ds(t)\\) is added to the leaf.\n\\[ \\frac{d\\mathcal{A}}{dt} = 2w |\\int_{s(t-1)/L}^{s(t)/L} \\mathcal{C}(\\frac{s(u)}{L})d\\frac{s(u)}{L}| \\]\nAccording to the Fundamental Theorem of Calculus, \\(\\mathcal{C}\\) being at least \\(C^0\\) on \\([0,L]\\), \\(F\\) being the antiderivative of \\(\\mathcal{C}\\), we can write:\n\\[ \\frac{d\\mathcal{A}}{dt} = 2w (|F(\\frac{s(t)}{L}) - F(\\frac{s(t-1)}{L})|) \\]\n\\[ F(\\frac{s(t)}{L}) = |\\frac{1}{2w} \\frac{d\\mathcal{A}}{dt} + F(\\frac{s(t-1)}{L})| \\]\nKnowing the other variables, we know have to determine \\(s(t)\\) at thermal time \\(t\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html#apparition-and-growth-of-phytomers-stem-and-leaf",
    "href": "dynamic_model.html#apparition-and-growth-of-phytomers-stem-and-leaf",
    "title": "4  Dynamic model",
    "section": "4.3 Apparition and growth of phytomers (stem and leaf)",
    "text": "4.3 Apparition and growth of phytomers (stem and leaf)\nThe height of the plant/canopy (here we consider the height of the main stem) is given by the crop model.\nThe plastochron (i.e. leaf initiation rate, in \\(leaf^{-1}\\)) is the time interval between two successive leaves produced at the SAM.\nThe phyllochron (i.e. leaf emergence rate, in \\(leaf^{-1}\\)) is the time interval between two successive leaves emerging from the top of the former leaf sheath.\nThe time for a leaf to grow is roughly between 1.5 and 2 phyllochrons.\nWe consider a linear (rough approximation of beta function) growth for the leaf.\n\n\\(\\phi\\) : phyllochron, in \\(^oC.day.leaf^{-1}\\)\ncur_len_int : current length of growing internodes\nfin_len_int : final length of internodes, in \\(cm\\) (literature, bell shaped model too ?)\ncur_len_leaf = \\([s_{g}(t)]\\) : current length of growing leaves\nfin_len_leaf : final length of leaves, in \\(cm\\) (bell shaped model)\ntime for leaf to grow, as \\(x * \\phi\\), in \\(^oC.day\\) (literature, cf Clerget et al., 2008, etc)\n\n\nCf Fournier et al, 2005",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html#modifying-the-mtg-of-a-growing-plant",
    "href": "dynamic_model.html#modifying-the-mtg-of-a-growing-plant",
    "title": "4  Dynamic model",
    "section": "4.4 Modifying the MTG of a growing plant",
    "text": "4.4 Modifying the MTG of a growing plant\nIn progress …\n\n\nCode\ndef mtg_turtle_time(g, symbols, time, update_visitor=None ):\n    ''' Compute the geometry on each node of the MTG using Turtle geometry. \n    \n    Update_visitor is a function called on each node in a pre order (parent before children).\n    This function allow to update the parameters and state variables of the vertices.\n    \n    :Example:\n\n        &gt;&gt;&gt; def grow(node, time):\n                \n    '''\n\n    g.properties()['geometry'] = {}\n    g.properties()['_plant_translation'] = {}\n\n    max_scale = g.max_scale()\n\n    def compute_element(n, symbols, time):\n        leaf = symbols.get('LeafElement')\n        stem = symbols.get('StemElement')\n\n        leaf_rank = int(n.complex().index())\n        optical_species = int(n.po)\n\n        metamer = n.complex()\n\n        # Length computation\n        if update_visitor:\n            length = n.length\n            final_length = metamer.final_length\n        else:\n            final_length = n.final_length\n            try :\n                length = final_length * (time - metamer.start_tt) / (metamer.end_tt - metamer.start_tt) if metamer.end_tt and time &lt; metamer.end_tt else n.length\n            except:\n                length = n.length\n\n        if update_visitor and  n.label.startswith('L'):\n            if metamer.final_length is None:\n                metamer.final_length = n.final_length\n                metamer.length = n.length\n            length = metamer.length\n            prev_length = metamer.final_length * (n.start_tt - metamer.start_tt) / (metamer.end_tt -metamer.start_tt)\n            s_base = (metamer.length - prev_length - n.length) / metamer.length\n        else:\n            s_base = n.srb\n        s_top = n.srt\n        seed = n.LcIndex\n        #leaf inclination\n\n        if update_visitor and  n.label.startswith('L'):\n            linc = metamer.insertion_angle\n        else:\n            linc = n.Linc\n \n        element = {} \n        if n.label.startswith('L'):\n            radius_max = n.Lw\n            element = leaf(optical_species, \n                        final_length, \n                        length, \n                        radius_max, \n                        s_base, \n                        s_top, \n                        leaf_rank, seed, linc) \n        else:\n            diameter_base = n.parent().diam if (n.parent() and n.parent().diam &gt; 0.) else n.diam\n            diameter_top = n.diam\n            element = stem( optical_species, length, diameter_base, diameter_top)\n\n        can_label =  element.get('label')\n        if can_label:\n            can_label.elt_id = leaf_rank\n            plant_node = n.complex_at_scale(scale=1)\n            can_label.plant_id = plant_node.index()\n            \n        geom = element.get('geometry')\n        \n        return geom, can_label\n\n    def adel_visitor(g, v, turtle, time):\n        # 1. retriev the node\n\n        n = g.node(v)\n\n        # Update visitor to compute or modified the node parameters\n        if update_visitor is not None:\n            update_visitor(n, time)\n\n            if 'Leaf' in n.label:\n                metamer = n.complex()\n                if (n.start_tt &lt;= time &lt; n.end_tt) or ((time &gt;= metamer.end_tt) and n.edge_type()=='+'):\n                    angle = float(metamer.Laz) if metamer.Laz else 0.\n                    turtle.rollL(angle)\n        else:\n            if 'Leaf' in n.label:\n                if n.edge_type()=='+':\n                    angle = float(n.Laz) if n.Laz else 0.\n                    turtle.rollL(angle)\n            else:\n                angle = float(n.Laz) if n.Laz else 0.\n                turtle.rollL(angle)\n        \n        if g.edge_type(v) == '+':\n            angle = n.Ginc or n.Einc\n            angle = float(angle) if angle is not None else 0.\n            #angle = n.inclination\n            #angle = float(angle) if angle is not None else 0.\n            turtle.up(angle)\n\n        # 2. Compute the geometric symbol\n        mesh, can_label = compute_element(n, symbols, time)\n        if mesh:\n            n.geometry = transform(turtle, mesh)\n            n.can_label = can_label\n\n        # 3. Update the turtle\n        turtle.setId(v)\n\n        m = n.complex()\n        if update_visitor:\n            length = n.length\n        else:\n            try:\n                length = n.length * (time - m.start_tt) / (m.end_tt - m.start_tt) if time &lt; m.end_tt else n.length\n            except:\n                length = n.length\n        if ('Leaf' not in n.label) and (length &gt; 0.):\n            turtle.F(length)\n        # Get the azimuth angle\n        \n\n    def traverse_with_turtle_time(g, vid, time, visitor=adel_visitor):\n        turtle = PglTurtle()\n        def push_turtle(v):\n            n = g.node(v)\n            #if 'Leaf' in n.label:\n                #    return False\n            try:\n                start_tt = n.complex().start_tt\n                if start_tt &gt; time:\n                    return False\n            except: \n                pass\n            if g.edge_type(v) == '+':\n                turtle.push()\n            return True\n\n        def pop_turtle(v):\n            n = g.node(v)\n            try:\n                start_tt = n.complex().start_tt\n                if start_tt &gt; time:\n                    return False\n            except: \n                pass\n            if g.edge_type(v) == '+':\n                turtle.pop()\n\n        if g.node(vid).complex().start_tt &lt;= time:\n            visitor(g,vid,turtle,time)\n            #turtle.push()\n        plant_id = g.complex_at_scale(vid, scale=1)\n        for v in pre_order2_with_filter(g, vid, None, push_turtle, pop_turtle):\n            if v == vid: continue\n            # Done for the leaves\n            if g.node(v).complex().start_tt &gt; time:\n                print('Do not consider ', v, time)\n                continue\n            visitor(g,v,turtle,time)\n\n        scene = turtle.getScene()\n        return g\n\n    for plant_id in g.component_roots_at_scale_iter(g.root, scale=max_scale):\n        g = traverse_with_turtle_time(g, plant_id, time)\n    return g\n\n\n\n\nCode\ndef thermal_time(g, phyllochron=110., leaf_duration=1.6, stem_duration=1.6, leaf_falling_rate = 10):\n    \"\"\"\n    Add dynamic properties on the mtg to simulate developpement\n    leaf_duration is the phyllochronic time for a leaf to develop from tip appearance to collar appearance\n    stem_duration is the phyllochronic time for a stem to develop\n    falling_rate (degrees / phyllochron) is the rate at which leaves fall after colar appearance\n    \"\"\"\n\n    plants = g.vertices(scale=1)\n    metamer_scale = g.max_scale()-1\n\n    for plant in plants:\n        tt = 0\n        v = next(g.component_roots_at_scale_iter(plant, scale=metamer_scale))\n        for metamer in pre_order2(g, v):\n            end_leaf = tt + phyllochron*leaf_duration\n            nm = g.node(metamer)\n            nm.start_tt = tt\n            nm.end_tt = end_leaf\n            nm.frate = leaf_falling_rate / phyllochron\n            sectors = [node for node in nm.components() if 'Leaf' in node.label]\n            stems = [node for node in nm.components() if 'Stem' in node.label]\n            \n            nb_stems = len(stems)\n            stem_tt = end_leaf\n            dtt = phyllochron*stem_duration / nb_stems\n            for stem in stems:\n                stem.start_tt = stem_tt\n                stem.end_tt = stem_tt+dtt\n                stem_tt += dtt\n\n            nb_sectors = max(1,len(sectors))\n            sector_tt = end_leaf\n            dtt = phyllochron*leaf_duration/nb_sectors \n            for sector in sectors:\n                sector.start_tt = sector_tt - dtt\n                sector.end_tt = sector_tt\n                sector_tt -= dtt\n\n            tt += phyllochron\n\n    return g\n\n\nThere are several ways to conceive the MTG for a growing plant.\nAt each thermal time step, the turtle visits each element and adds a value to a time series for each (almost) properties of the MTG.\nOR\nAt each thermal time step, the MTG is replicated and the growing elements ar modified, and new elements are added if needed.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  },
  {
    "objectID": "dynamic_model.html#next-steps",
    "href": "dynamic_model.html#next-steps",
    "title": "4  Dynamic model",
    "section": "4.5 Next steps",
    "text": "4.5 Next steps\n\nConstrains from crop model\nBending dynamics of leaves and tillers",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Dynamic model</span>"
    ]
  }
]